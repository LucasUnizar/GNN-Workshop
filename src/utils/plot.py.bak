import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib import animation
import os
import torch
import wandb

from scipy.io import savemat
import os
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import matplotlib.animation as animation
import wandb

def plot_3D(z_net, z_gt, X, Y, save_dir='outputs/gifs/', name='Liver_actuator'):
    """
    This function creates a 3D scatter plot comparing Data Driven MeshGraphs predictions with ground truth
    and saves the data as .mat files for later use in MATLAB.

    Parameters:
    z_net (torch.Tensor): Predictions from the GNN.
    z_gt (torch.Tensor): Ground truth data.
    X (torch.Tensor): X-coordinates.
    Y (torch.Tensor): Y-coordinates.
    save_dir (str): Directory to save the plot.
    name (str): Name for the plot and file.

    Returns:
    None
    """
    T = z_net.shape[0]  # Number of snapshots

    # Ensure save directory exists
    os.makedirs(save_dir, exist_ok=True)

    # Save data for MATLAB
    mat_file_path = os.path.join(save_dir, f'{name}_data.mat')
    mat_data = {
        'z_net': z_net,
        'z_gt': z_gt,
        'X': X,
        'Y': Y
    }
    savemat(mat_file_path, mat_data)
    print(f"Data saved for MATLAB at {mat_file_path}")

    # Plot initialization
    fig = plt.figure(figsize=(14, 8))
    ax1 = fig.add_subplot(1, 2, 1, projection='3d')
    ax2 = fig.add_subplot(1, 2, 2, projection='3d')
    ax1.set_title('GNN Prediction', fontsize=18, fontfamily='serif')
    ax1.set_xlabel('X'), ax1.set_ylabel('Y'), ax1.set_zlabel('Z')
    ax2.set_title('Ground Truth', fontsize=18, fontfamily='serif')
    ax2.set_xlabel('X'), ax2.set_ylabel('Y'), ax2.set_zlabel('Z')

    # Adjust ranges
    tensor_max = max(z_gt.max(), z_net.max())
    tensor_min = min(z_gt.min(), z_net.min())
    z_min, z_max = tensor_min.item(), tensor_max.item()

    # Initial snapshot
    var_net0, var_gt0 = z_net[0].flatten(), z_gt[0].flatten()
    sc1 = ax1.scatter(X, Y, var_net0, c=var_net0, cmap='plasma', vmax=z_max, vmin=z_min)
    sc2 = ax2.scatter(X, Y, var_gt0, c=var_gt0, cmap='plasma', vmax=z_max, vmin=z_min)

    # Colorbars
    cbar1 = fig.colorbar(sc1, ax=ax1, shrink=0.5, pad=0.1)
    cbar2 = fig.colorbar(sc2, ax=ax2, shrink=0.5, pad=0.1)
    cbar1.set_label(r'$u_{i}$', fontsize=14, labelpad=10)
    cbar2.set_label(r'$u_{i}$', fontsize=14, labelpad=10)

    # Animation
    def animate(snap):
        print(f'Animating snapshot {snap + 1}/{T}')
        ax1.clear()
        ax2.clear()
        ax1.set_title('GNN Prediction', fontsize=18, fontfamily='serif')
        ax1.set_xlabel('X'), ax1.set_ylabel('Y'), ax1.set_zlabel('Z')
        ax2.set_title('Ground Truth', fontsize=18, fontfamily='serif')
        ax2.set_xlabel('X'), ax2.set_ylabel('Y'), ax2.set_zlabel('Z')

        var_net, var_gt = z_net[snap].flatten(), z_gt[snap].flatten()
        sc1 = ax1.scatter(X, Y, var_net, c=var_net, cmap='plasma', vmax=z_max, vmin=z_min)
        sc2 = ax2.scatter(X, Y, var_gt, c=var_gt, cmap='plasma', vmax=z_max, vmin=z_min)

        return fig,

    anim = FuncAnimation(fig, animate, frames=T, repeat=False)
    writergif = animation.PillowWriter(fps=25)

    # Save as gif
    gif_file_path = os.path.join(save_dir, f'{name}_3Dscatter.gif')
    anim.save(gif_file_path, writer=writergif)
    wandb.log({f'{name}_3Dscatter': wandb.Image(gif_file_path)})
    print(f"GIF saved at {gif_file_path}")
    plt.close()


def plot_error(z_net, z_gt, X, Y, save_dir='outputs/gifs/', name='Error_plot'):
    """
    This function plots the error between GNN predictions and ground truth.

    Parameters:
    z_net (torch.Tensor): Predictions from the GNN.
    z_gt (torch.Tensor): Ground truth data.
    X (torch.Tensor): X-coordinates.
    Y (torch.Tensor): Y-coordinates.
    save_dir (str): Directory to save the plot.
    name (str): Name for the plot and file.

    Returns:
    None
    """
    T = z_net.shape[0]  # Number of snapshots

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(1, 1, 1, projection='3d')
    ax.set_title('Prediction Error', fontsize=18, fontfamily='serif')
    ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Error')

    # Animation
    def animate(snap):
        ax.clear()
        ax.set_title('Prediction Error', fontsize=18, fontfamily='serif')
        ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Error')

        error = (z_net[snap] - z_gt[snap])**2
        sc = ax.scatter(X, Y, error, c=error, cmap='coolwarm', vmax=error.max(), vmin=error.min())
        return sc,

    anim = FuncAnimation(fig, animate, frames=T, repeat=False)
    writergif = animation.PillowWriter(fps=25)

    save_dir = save_dir + name + '_error.gif'
    anim.save(save_dir, writer=writergif)
    wandb.log({f'{name}_error': wandb.Image(save_dir)})
    plt.close()

def plot_combined(z_net, z_gt, X, Y, save_dir='outputs/gifs/', name='Combined_plot'):
    """
    This function overlays GNN predictions and ground truth in a single plot for comparison.

    Parameters:
    z_net (torch.Tensor): Predictions from the GNN.
    z_gt (torch.Tensor): Ground truth data.
    X (torch.Tensor): X-coordinates.
    Y (torch.Tensor): Y-coordinates.
    save_dir (str): Directory to save the plot.
    name (str): Name for the plot and file.

    Returns:
    None
    """
    T = z_net.shape[0]  # Number of snapshots

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(1, 1, 1, projection='3d')
    ax.set_title('Prediction vs Ground Truth', fontsize=18, fontfamily='serif')
    ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Z')

    # Animation
    def animate(snap):
        ax.clear()
        ax.set_title('Prediction vs Ground Truth', fontsize=18, fontfamily='serif')
        ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Z')

        var_net = z_net[snap].flatten()
        var_gt = z_gt[snap].flatten()

        sc_net = ax.scatter(X, Y, var_net, c='blue', label='Prediction', alpha=0.6)
        sc_gt = ax.scatter(X, Y, var_gt, c='red', label='Ground Truth', alpha=0.6)
        ax.legend()

        return sc_net, sc_gt

    anim = FuncAnimation(fig, animate, frames=T, repeat=False)
    writergif = animation.PillowWriter(fps=25)

    save_dir = save_dir + name + '_combined.gif'
    anim.save(save_dir, writer=writergif)
    wandb.log({f'{name}_combined': wandb.Image(save_dir)})
    plt.close()

def plot_mssg(mssg, x, y, save_dir='outputs/gifs/', name='message_passing', idx=0):
    """
    This function creates an animated 3D plot with three subplots, each representing message values at fixed z_gt positions 
    over T frames. Colorbars are added to each subplot.

    Parameters:
    mssg (list of torch.Tensor): List of message tensors containing variable values.
    z_gt (torch.Tensor): Fixed 3D positions (ground truth).
    n (torch.Tensor): Binary mask for distinguishing data subsets.
    save_dir (str): Directory to save the plot.
    name (str): Base name for the saved plot.
    idx (int): Index for naming the saved plot.

    Returns:
    None
    """
    
    # Number of frames in the animation
    T = len(mssg[0])
    mssg_0, mssg_10, mssg_20 = mssg[0], mssg[11], mssg[21]
    mssg0_t, mssg10_t, mssg20_t = [0]*T, [0]*T, [0]*T
    for t in range(T):
        mssg0_t[t] = mssg_0[t] / mssg_0[0]
        mssg10_t[t] = mssg_10[t] / mssg_10[0]
        mssg20_t[t] = mssg_20[t] / mssg_20[0]

    # Set up figure and 3D subplots
    fig = plt.figure(figsize=(18, 5))
    ax1 = fig.add_subplot(1, 3, 1, projection='3d')
    ax2 = fig.add_subplot(1, 3, 2, projection='3d')
    ax3 = fig.add_subplot(1, 3, 3, projection='3d')
    
    # Titles for subplots
    ax1.set_title('Snapshot 0', fontsize=16)
    ax2.set_title('Snapshot 10', fontsize=16)
    ax3.set_title('Snapshot 20', fontsize=16)

    # Common axis labels
    for ax in [ax1, ax2, ax3]:
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.view_init(elev=20, azim=40)
        ax.grid()
        # Hide ticks
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        ax.set_zticklabels([])

    # Determine variable range for color consistency
    X, Y, Z = x, y, np.zeros_like(x)
    z_min0, z_max0 = np.min(np.concatenate(mssg0_t)), np.max(np.concatenate(mssg0_t))
    z_min10, z_max10 = np.min(np.concatenate(mssg10_t)), np.max(np.concatenate(mssg10_t))
    z_min20, z_max20 = np.min(np.concatenate(mssg20_t)), np.max(np.concatenate(mssg20_t))
    z_min = min(z_min0, z_min10, z_min20)
    z_max = max(z_max0, z_max10, z_max20)
    
    # Bounding box settings
    max_range = np.array([X.max() - X.min(), Y.max() - Y.min(), Z.max() - Z.min()]).max()
    Xb = 0.5 * max_range * np.mgrid[-1:2:2, -1:2:2, -1:2:2][0].flatten() + 0.5 * (X.max() + X.min())
    Yb = 0.5 * max_range * np.mgrid[-1:2:2, -1:2:2, -1:2:2][1].flatten() + 0.5 * (Y.max() + Y.min())
    Zb = 0.5 * max_range * np.mgrid[-1:2:2, -1:2:2, -1:2:2][2].flatten() + 0.5 * (Z.max() + Z.min())

    # Initialize scatter plots for first frame and colorbars
    s1 = ax1.scatter(X, Y, Z, c=mssg0_t[0], cmap='jet', vmin=z_min0, vmax=z_max0)
    s2 = ax2.scatter(X, Y, Z, c=mssg10_t[0], cmap='jet', vmin=z_min10, vmax=z_max10)
    s3 = ax3.scatter(X, Y, Z, c=mssg20_t[0], cmap='jet', vmin=z_min20, vmax=z_max20)
    fig.colorbar(s1, ax=ax1, shrink=0.5, aspect=10)
    fig.colorbar(s2, ax=ax2, shrink=0.5, aspect=10)
    fig.colorbar(s3, ax=ax3, shrink=0.5, aspect=10)

    def animate(t):
        ax1.cla()
        ax2.cla()
        ax3.cla()
        
        # Setup titles and labels for each frame
        ax1.set_title('Message Level 0')
        ax2.set_title('Message Level 10')
        ax3.set_title('Message Level 20')
        
        # Scatter plot with values from mssg, but positions from z_gt
        s1 = ax1.scatter(X, Y, Z, c=mssg0_t[t], cmap='jet', vmin=z_min0, vmax=z_max0)
        s2 = ax2.scatter(X, Y, Z, c=mssg10_t[t], cmap='jet', vmin=z_min10, vmax=z_max10)
        s3 = ax3.scatter(X, Y, Z, c=mssg20_t[t], cmap='jet', vmin=z_min20, vmax=z_max20)
        
        # Bounding box
        for xb, yb, zb in zip(Xb, Yb, Zb):
            ax1.plot([xb], [yb], [zb], 'w')
            ax2.plot([xb], [yb], [zb], 'w')
            ax3.plot([xb], [yb], [zb], 'w')
        
        return fig,

    # Create animation
    anim = animation.FuncAnimation(fig, animate, frames=T, repeat=False)
    writergif = animation.PillowWriter(fps=6)

    # Save animation as a GIF
    save_path = f"{save_dir}/{name}_mssg_{idx}.gif"
    anim.save(save_path, writer=writergif)
    plt.close()

def boxplot_error(test_error, save_path='outputs/test_statistics/', name='Liver_actuator', error='RMSE'):
    """
    Create a boxplot for a single error type in the test set,
    with individual data points plotted as dots to the left of the boxplot.

    Parameters:
    test_error (list): List containing testing errors.
    save_path (str): Path to save the boxplot image. Default is 'outputs/test_statistics/'.
    name (str): Name of the plot for saving purposes.

    Returns:
    None
    """
    # Create a new figure
    fig, ax = plt.subplots(figsize=(3, 4))  # Longer and thinner figure
    test_error = np.array(test_error)

    # Define the boxplot position and scatter offset
    position = 1
    scatter_offset = -0.15  # Offset for scatter points

    # Define color for the boxplot and scatter points
    color = 'darkblue'

    # Create the boxplot
    bp = ax.boxplot(test_error, positions=[position], widths=0.15, patch_artist=True,
                    boxprops=dict(facecolor='white', edgecolor=color, linewidth=2), showfliers=False)

    # Add scatter points
    ax.scatter(np.full_like(test_error, position + scatter_offset), test_error, color=color, alpha=0.6, edgecolor='w', zorder=3)

    # Set y-axis to log scale
    ax.set_yscale('log')
    ax.tick_params(axis='y', labelsize=12)  # Smaller y-axis labels

    # Customize font size and family
    ax.set_xlabel(error, fontsize=16, fontfamily='serif')

    # Adjust x-axis ticks and labels
    ax.set_xticks([position])
    ax.set_xticklabels([r'Test Error'], fontsize=16, fontfamily='serif', fontweight='bold', fontstyle='italic')

    # Add grid lines for better readability
    ax.grid(axis='y', linestyle='--', alpha=1.0)

    # Customize the plot background
    ax.set_facecolor('whitesmoke')

    # Save the boxplot image with a transparent background
    save_path = save_path + name + '_boxplot.png'
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    plt.savefig(save_path, bbox_inches='tight', transparent=True)
    plt.close()

def plot_frame(z_net, z_gt, X, Y, frame_idx=0, save_dir='outputs/images/', name='Combined_plot'):
    """
    This function overlays GNN predictions and ground truth for a specific frame.

    Parameters:
    z_net (torch.Tensor): Predictions from the GNN.
    z_gt (torch.Tensor): Ground truth data.
    X (torch.Tensor): X-coordinates.
    Y (torch.Tensor): Y-coordinates.
    frame_idx (int): Index of the frame to visualize.
    save_dir (str): Directory to save the plot.
    name (str): Name for the plot and file.

    Returns:
    None
    """
    # Validate frame index
    if frame_idx < 0 or frame_idx >= z_net.shape[0]:
        raise ValueError(f"Invalid frame_idx: {frame_idx}. Must be between 0 and {z_net.shape[0] - 1}.")

    # Extract data for the specified frame
    var_net = z_net[frame_idx].flatten()
    var_gt = z_gt[frame_idx].flatten()

    # Create the plot
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(1, 1, 1, projection='3d')
    ax.set_title('Prediction vs Ground Truth', fontsize=18, fontfamily='serif')
    ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Z')

    # Scatter plots for predictions and ground truth
    ax.scatter(X, Y, var_net, c='blue', label='Prediction', alpha=0.6)
    ax.scatter(X, Y, var_gt, c='red', label='Ground Truth', alpha=0.6)
    ax.legend()

    # Save the plot
    save_path = f"{save_dir}{name}_frame_{frame_idx}.png"
    plt.savefig(save_path)
    print(f"Plot saved to {save_path}")

    # Optionally, log to wandb
    try:
        import wandb
        wandb.log({f'{name}_frame_{frame_idx}': wandb.Image(save_path)})
    except ImportError:
        print("wandb not available. Skipping wandb logging.")

    plt.close()